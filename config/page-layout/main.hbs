<html lang="en">

  <head>
    <link rel="icon" href="/assets/no_auth/images/logos/favicon.ico">


    <meta name="version" content="{{version}}" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta charset="utf-8">

    <link rel="icon" href="/assets/no_auth/images/logos/favicon.ico">
    <link href="/assets/css_variables.css" rel="stylesheet" type="text/css" />

    {{#each assetsMap.app.css}}
      <link href="{{this}}" rel="stylesheet" type="text/css" />
    {{/each}}

    {{{html-head}}}
    {{#each assetsMap.app.js}}
      <script defer type="text/javascript" src="{{this}}"></script>
    {{/each}}

    <link
        href="/assets/new-styles/global.css"
        rel="stylesheet"
        type="text/css"
    />

    <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap" rel="stylesheet">
    <script>
      (function() {
      console.log('[Color Overlay] Script loaded');
      // Check if we're on the demo page
      if (window.location.href.endsWith('/resource/start')) {
        console.log('[Color Overlay] Demo page detected, initializing...');

        // Configuration mode for color areas:
        // 'always' - Areas are always visible (useful for debugging)
        // 'hover' - Areas are only visible when mouse is inside the polygon
        // 'none' - Areas are disabled completely
        const colorAreasMode = 'hover'; // Change to 'always' for debugging
        
        // Skip if feature is disabled
        if (colorAreasMode === 'none') return;
        // Wait for DOM to be loaded
        document.addEventListener('DOMContentLoaded', () => {
          console.log('[Color Overlay] Initializing for demo page');
          
          // Function to initialize when the image is loaded
          const initializeImageOverlays = () => {
            const heroImage = document.querySelector('.hero-image');
            if (!heroImage) {
              // If image not found yet, try again in a moment
              console.log('[Color Overlay] Hero image not found yet, retrying...');
              setTimeout(initializeImageOverlays, 200);
              return;
            }
            
            // Make sure image dimensions are available
            if (!heroImage.complete) {
              console.log('[Color Overlay] Image not fully loaded, waiting...');
              heroImage.addEventListener('load', initializeImageOverlays);
              return;
            }
            
            console.log('[Color Overlay] Hero image found and loaded', heroImage.width, 'x', heroImage.height);
            console.log('[Color Overlay] Natural dimensions:', heroImage.naturalWidth, 'x', heroImage.naturalHeight);
            
            const container = heroImage.closest('.hero-image-container');
            const dstImage = heroImage.getAttribute('dst');
            
            if (!dstImage) {
              console.error('[Color Overlay] No dst attribute found on hero image');
              return;
            }
            
            // Get all area elements from the image map
            const areas = document.querySelectorAll('map[name="image-map"] area');
            console.log('[Color Overlay] Found', areas.length, 'areas in image map');
            
            // Helper function to check if a point is inside a polygon
            // Uses ray casting algorithm
            const isPointInPolygon = (point, polygon) => {
              // Ray casting algorithm
              let inside = false;
              for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i][0], yi = polygon[i][1];
                const xj = polygon[j][0], yj = polygon[j][1];
                
                const intersect = ((yi > point[1]) !== (yj > point[1])) &&
                  (point[0] < (xj - xi) * (point[1] - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
              }
              return inside;
            };
            
            // Use naturalWidth/naturalHeight if available, otherwise fall back to width/height
            const imgWidth = heroImage.naturalWidth || heroImage.width;
            const imgHeight = heroImage.naturalHeight || heroImage.height;
            
            console.log(`[Color Overlay] Using dimensions for calculation: ${imgWidth} x ${imgHeight}`);
            
            // Store all overlays and their polygon data for hit testing
            const overlayData = [];
            
            // Process each area
            areas.forEach((area, index) => {
              // Get coordinates
              const coords = area.getAttribute('coords').split(',').map(Number);
              console.log(`[Color Overlay] Processing area ${index + 1}:`, area.getAttribute('title') || 'Unnamed area', 'Coords:', coords);
              
              // Create a polygon string for clip-path
              let polygonPoints = '';
              
              // Create polygon points array for hit testing
              const polygonPointsArray = [];
              
              for (let i = 0; i < coords.length; i += 2) {
                // Calculate percentages based on image dimensions
                const x = (coords[i] / imgWidth) * 100;
                const y = (coords[i + 1] / imgHeight) * 100;
                polygonPoints += `${x}% ${y}%, `;
                
                // Store original coordinates for hit testing
                polygonPointsArray.push([coords[i], coords[i + 1]]);
              }
              polygonPoints = polygonPoints.slice(0, -2); // Remove trailing comma and space
              console.log(`[Color Overlay] Area ${index + 1} clip-path:`, `polygon(${polygonPoints})`);
              
              // Create overlay for this area
              const overlay = document.createElement('div');
              overlay.className = 'color-overlay-area';
              overlay.style.position = 'absolute';
              overlay.style.top = '0';
              overlay.style.left = '0';
              overlay.style.width = '100%';
              overlay.style.height = '100%';
              overlay.style.backgroundImage = `url(${dstImage})`;
              overlay.style.backgroundSize = 'cover';
              overlay.style.backgroundPosition = 'center';
              overlay.style.backgroundRepeat = 'no-repeat';
              overlay.style.clipPath = `polygon(${polygonPoints})`;
              overlay.style.zIndex = '2';
              
              // Set initial visibility based on mode
              if (colorAreasMode === 'hover') {
                overlay.style.opacity = '0';
                overlay.style.transition = 'opacity 0.2s ease-in-out';
              }
              
              // Add a title for debugging
              if (area.getAttribute('title')) {
                overlay.setAttribute('title', area.getAttribute('title'));
              }
              
              container.appendChild(overlay);
              console.log(`[Color Overlay] Added overlay for area ${index + 1}`);
              
              // Store overlay and its polygon data for hit testing
              overlayData.push({
                overlay,
                polygon: polygonPointsArray
              });
            });
            
            // Add mouse events to container if in hover mode
            if (colorAreasMode === 'hover') {
              // Single mousemove event listener for all overlays
              container.addEventListener('mousemove', (event) => {
                // Get mouse position relative to the image
                const rect = heroImage.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;
                
                // Check if mouse is within the image bounds
                if (mouseX < 0 || mouseY < 0 || mouseX > rect.width || mouseY > rect.height) {
                  // Mouse is outside the image, hide all overlays
                  overlayData.forEach(data => {
                    data.overlay.style.opacity = '0';
                  });
                  return;
                }
                
                // Scale mouse position to match original image coordinates
                const scaledX = (mouseX / rect.width) * imgWidth;
                const scaledY = (mouseY / rect.height) * imgHeight;
                
                // Track if mouse is inside any polygon
                let insideAny = false;
                
                // Reset all i elements with iri attributes to opacity 0
                document.querySelectorAll('i[iri]').forEach(icon => {
                  icon.style.opacity = '0';
                });
                
                // Check each polygon
                overlayData.forEach((data, index) => {
                  const isInside = isPointInPolygon([scaledX, scaledY], data.polygon);
                  
                  // Show/hide overlay based on mouse position
                  data.overlay.style.opacity = isInside ? '1' : '0';
                  
                  if (isInside) {
                    insideAny = true;
                    
                    // Get the iri attribute from the corresponding area
                    const area = areas[index];
                    const iri = area.getAttribute('iri');
                    
                    // If area has an iri attribute, find and show the matching i element
                    if (iri) {
                      console.log(`[Color Overlay] Area has IRI: ${iri}, looking for matching icon`);
                      const matchingIcon = document.querySelector(`i[iri="${iri}"]`);
                      if (matchingIcon) {
                        console.log(`[Color Overlay] Found matching icon for IRI: ${iri}`);
                        matchingIcon.style.opacity = '1';
                        matchingIcon.style.transition = 'opacity 0.2s ease-in-out';
                      }
                    }
                  }
                });
                
                // If not inside any polygon, ensure all are hidden
                if (!insideAny) {
                  overlayData.forEach(data => {
                    data.overlay.style.opacity = '0';
                  });
                  // Also hide all i elements with iri attributes
                  document.querySelectorAll('i[iri]').forEach(icon => {
                    icon.style.opacity = '0';
                  });
                }
              });
              
              // Add mouseleave event to hide all overlays and icons when mouse leaves the container
              container.addEventListener('mouseleave', () => {
                // Hide all overlays
                overlayData.forEach(data => {
                  data.overlay.style.opacity = '0';
                });
                
                // Hide all i elements with iri attributes
                document.querySelectorAll('i[iri]').forEach(icon => {
                  icon.style.opacity = '0';
                });
              });
            }
            
            console.log('[Color Overlay] All areas processed and overlays created successfully');
          };
          
          // Start the initialization process with a small delay to ensure DOM is fully rendered
          setTimeout(initializeImageOverlays, 1000);
        });
      }
      })();
    </script>
   </head>

  <body>
    <div id="application" class="rs-application"></div>
  </body>

</html>
